{
  "id": "c-day46-ex00-ft-bubble-sort",
  "category": "c",
  "day": 46,
  "order": 0,
  "title": "Tri a bulles (Bubble Sort)",
  "description": "Ecris une fonction ft_bubble_sort(int *tab, int size) qui trie un tableau d'entiers par ordre croissant en utilisant l'algorithme du tri a bulles. Le principe est simple : on parcourt le tableau et on echange (swap) chaque paire d'elements adjacents qui sont dans le mauvais ordre. On repete jusqu'a ce qu'aucun echange ne soit necessaire. Prototype : void ft_bubble_sort(int *tab, int size);",
  "difficulty": 3,
  "points": 30,
  "estimatedTime": 35,
  "learningObjectives": [
    "Comprendre le principe du tri a bulles et ses boucles imbriquees",
    "Savoir effectuer un swap de deux variables en C",
    "Maitriser la notion de parcours repetitif jusqu'a stabilisation",
    "Identifier la complexite temporelle d'un algorithme de tri simple",
    "Implementer un algorithme de tri complet sur un tableau d'entiers"
  ],
  "learningContent": {
    "lesson": {
      "introduction": "Le tri a bulles (Bubble Sort) est l'un des algorithmes de tri les plus simples a comprendre et a implementer. Son nom vient du fait que les plus grands elements 'remontent' progressivement vers la fin du tableau, comme des bulles dans l'eau. A chaque passage, on compare chaque element avec son voisin et on les echange s'ils sont dans le mauvais ordre. On repete ce processus jusqu'a ce que le tableau soit entierement trie. Bien que cet algorithme ne soit pas le plus performant (complexite O(n²)), il est parfait pour debuter avec les algorithmes de tri et comprendre les concepts fondamentaux : comparaison, echange, et convergence.",
      "steps": [
        {
          "id": 1,
          "title": "Le principe du swap (echange)",
          "content": "Avant de coder un tri, il faut savoir echanger deux elements. En C, on ne peut pas simplement ecrire `a = b; b = a;` car la premiere valeur serait perdue. On utilise une **variable temporaire** pour sauvegarder une des deux valeurs.\n\n**Les etapes du swap :**\n1. Sauvegarder la valeur de `a` dans `tmp`\n2. Copier `b` dans `a`\n3. Copier `tmp` (ancienne valeur de `a`) dans `b`\n\nCette operation est la brique de base de tous les algorithmes de tri par echange.",
          "codeExample": "// Swap de deux entiers via pointeurs\nvoid\tft_swap(int *a, int *b)\n{\n\tint\ttmp;\n\n\ttmp = *a;\n\t*a = *b;\n\t*b = tmp;\n}\n\n// Swap directement dans un tableau\nint tab[] = {5, 3};\nint tmp = tab[0];\ntab[0] = tab[1];\ntab[1] = tmp;\n// tab = {3, 5}",
          "language": "c",
          "tryItYourself": {
            "instruction": "Si a = 10 et b = 20, ecris les 3 lignes du swap avec une variable tmp. Quelles sont les valeurs apres chaque ligne ?",
            "starterCode": "int a = 10;\nint b = 20;\nint tmp;\n// Ligne 1 : tmp = ???  -> a=10, b=20, tmp=?\n// Ligne 2 : a = ???    -> a=?, b=20, tmp=?\n// Ligne 3 : b = ???    -> a=?, b=?, tmp=?",
            "solution": "int a = 10;\nint b = 20;\nint tmp;\ntmp = a;  // a=10, b=20, tmp=10\na = b;    // a=20, b=20, tmp=10\nb = tmp;  // a=20, b=10, tmp=10"
          }
        },
        {
          "id": 2,
          "title": "L'algorithme du tri a bulles",
          "content": "Le tri a bulles fonctionne par **passages successifs** sur le tableau :\n\n1. On parcourt le tableau de gauche a droite\n2. Pour chaque paire d'elements adjacents (tab[j] et tab[j+1]) :\n   - Si tab[j] > tab[j+1], on les echange\n3. Apres un passage complet, le plus grand element est a la fin\n4. On recommence en excluant le dernier element (deja place)\n5. On repete jusqu'a n'avoir plus d'echanges a faire\n\n**Pourquoi ca marche ?** A chaque passage, le plus grand element non trie 'bulle' vers sa position finale. Apres k passages, les k plus grands elements sont en place.",
          "codeExample": "// Exemple avec tab = {5, 3, 8, 1}\n// Passage 1 :\n//   [5,3] -> swap -> {3, 5, 8, 1}\n//   [5,8] -> ok   -> {3, 5, 8, 1}\n//   [8,1] -> swap -> {3, 5, 1, 8}  <- 8 est place\n// Passage 2 :\n//   [3,5] -> ok   -> {3, 5, 1, 8}\n//   [5,1] -> swap -> {3, 1, 5, 8}  <- 5 est place\n// Passage 3 :\n//   [3,1] -> swap -> {1, 3, 5, 8}  <- 3 est place\n// Tableau trie !",
          "language": "c",
          "tryItYourself": {
            "instruction": "Avec le tableau {4, 2, 7, 1}, fais le premier passage du bubble sort. Quels swaps se produisent et quel element se retrouve a la fin ?",
            "starterCode": "// tab = {4, 2, 7, 1}\n// Compare tab[0] et tab[1] : 4 > 2 ? -> ???\n// Compare tab[1] et tab[2] : ? > ? ? -> ???\n// Compare tab[2] et tab[3] : ? > ? ? -> ???\n// Resultat apres passage 1 : {?, ?, ?, ?}",
            "solution": "// tab = {4, 2, 7, 1}\n// Compare 4 > 2 ? Oui -> swap -> {2, 4, 7, 1}\n// Compare 4 > 7 ? Non -> pas de swap -> {2, 4, 7, 1}\n// Compare 7 > 1 ? Oui -> swap -> {2, 4, 1, 7}\n// Apres passage 1 : {2, 4, 1, 7}\n// 7 (le max) est maintenant a la fin"
          }
        },
        {
          "id": 3,
          "title": "Les boucles imbriquees du bubble sort",
          "content": "L'implementation du tri a bulles utilise **deux boucles imbriquees** :\n\n- **Boucle externe (i)** : controle le nombre de passages. Apres chaque passage, un element de plus est a sa place.\n- **Boucle interne (j)** : parcourt les elements non tries et effectue les comparaisons/echanges.\n\n**Optimisation importante :** On peut reduire la taille de la boucle interne a chaque passage, car les derniers elements sont deja tries. De plus, si un passage ne produit aucun swap, le tableau est trie et on peut s'arreter.",
          "codeExample": "void\tft_bubble_sort(int *tab, int size)\n{\n\tint\ti;\n\tint\tj;\n\tint\ttmp;\n\n\ti = 0;\n\twhile (i < size - 1)\n\t{\n\t\tj = 0;\n\t\twhile (j < size - 1 - i)\n\t\t{\n\t\t\tif (tab[j] > tab[j + 1])\n\t\t\t{\n\t\t\t\ttmp = tab[j];\n\t\t\t\ttab[j] = tab[j + 1];\n\t\t\t\ttab[j + 1] = tmp;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\t}\n}",
          "language": "c",
          "tryItYourself": {
            "instruction": "Pourquoi la boucle interne va jusqu'a size - 1 - i et pas simplement size - 1 ?",
            "starterCode": "// Apres le passage i=0, le plus grand est en position size-1\n// Apres le passage i=1, le 2e plus grand est en position ???\n// Donc a chaque passage, on peut ignorer ??? elements a la fin",
            "solution": "// Apres le passage i=0, le plus grand est en position size-1\n// Apres le passage i=1, le 2e plus grand est en position size-2\n// Donc a chaque passage i, on peut ignorer i elements a la fin\n// La borne est size - 1 - i car les i derniers sont deja tries"
          }
        },
        {
          "id": 4,
          "title": "Optimisation avec un flag de swap",
          "content": "Une optimisation classique du bubble sort consiste a utiliser un **flag** (drapeau) qui indique si au moins un echange a eu lieu pendant le passage courant.\n\n**Si aucun echange n'a eu lieu**, cela signifie que le tableau est deja trie et on peut s'arreter immediatement. Cette optimisation rend le meilleur cas en O(n) au lieu de O(n²).\n\n**Complexite :**\n- Pire cas : O(n²) - tableau trie en ordre inverse\n- Meilleur cas (avec flag) : O(n) - tableau deja trie\n- Cas moyen : O(n²)\n- Espace : O(1) - tri en place",
          "codeExample": "void\tft_bubble_sort_opti(int *tab, int size)\n{\n\tint\ti;\n\tint\tj;\n\tint\ttmp;\n\tint\tswapped;\n\n\ti = 0;\n\twhile (i < size - 1)\n\t{\n\t\tswapped = 0;\n\t\tj = 0;\n\t\twhile (j < size - 1 - i)\n\t\t{\n\t\t\tif (tab[j] > tab[j + 1])\n\t\t\t{\n\t\t\t\ttmp = tab[j];\n\t\t\t\ttab[j] = tab[j + 1];\n\t\t\t\ttab[j + 1] = tmp;\n\t\t\t\tswapped = 1;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (!swapped)\n\t\t\tbreak ;\n\t\ti++;\n\t}\n}",
          "language": "c"
        }
      ]
    },
    "theory": [
      {
        "title": "Principe du tri a bulles",
        "content": "Le tri a bulles est un algorithme de tri par comparaison. Il parcourt le tableau a plusieurs reprises, compare les elements adjacents et les echange s'ils sont dans le mauvais ordre. Le nom vient du fait que les plus grands elements 'remontent' progressivement vers la fin, comme des bulles d'air dans l'eau.",
        "codeExamples": [
          {
            "title": "Bubble sort basique",
            "code": "void\tft_bubble_sort(int *tab, int size)\n{\n\tint\ti;\n\tint\tj;\n\tint\ttmp;\n\n\ti = 0;\n\twhile (i < size - 1)\n\t{\n\t\tj = 0;\n\t\twhile (j < size - 1 - i)\n\t\t{\n\t\t\tif (tab[j] > tab[j + 1])\n\t\t\t{\n\t\t\t\ttmp = tab[j];\n\t\t\t\ttab[j] = tab[j + 1];\n\t\t\t\ttab[j + 1] = tmp;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\t}\n}",
            "explanation": "Double boucle : la boucle externe controle les passages, la boucle interne compare et echange les elements adjacents"
          }
        ],
        "keyPoints": [
          "On compare chaque element avec son voisin de droite",
          "Si l'element de gauche est plus grand, on echange",
          "Apres chaque passage, le plus grand non-trie est a sa place",
          "On repete jusqu'a ce que tout soit trie"
        ],
        "commonMistakes": [
          "Oublier le -1 dans la borne de la boucle interne (acces hors tableau)",
          "Ne pas reduire la borne avec -i (compare des elements deja tries)",
          "Inverser la condition : tab[j] < tab[j+1] trie en ordre decroissant"
        ]
      },
      {
        "title": "Le swap en C",
        "content": "L'echange (swap) de deux variables est l'operation fondamentale de la plupart des algorithmes de tri. En C, il faut obligatoirement utiliser une variable temporaire car il n'existe pas d'instruction native pour echanger deux valeurs.",
        "codeExamples": [
          {
            "title": "Swap avec variable temporaire",
            "code": "// Swap dans un tableau\nint tmp = tab[j];\ntab[j] = tab[j + 1];\ntab[j + 1] = tmp;\n\n// Swap via pointeurs (fonction)\nvoid\tft_swap(int *a, int *b)\n{\n\tint\ttmp;\n\n\ttmp = *a;\n\t*a = *b;\n\t*b = tmp;\n}",
            "explanation": "Sans variable temporaire, la premiere affectation ecrase la valeur originale et elle est perdue"
          }
        ],
        "keyPoints": [
          "Toujours utiliser une variable temporaire pour le swap",
          "L'ordre des 3 lignes est important et ne doit pas etre modifie",
          "Pour swapper dans un tableau : tmp = tab[i]; tab[i] = tab[j]; tab[j] = tmp;",
          "Avec des pointeurs : tmp = *a; *a = *b; *b = tmp;"
        ],
        "commonMistakes": [
          "Oublier la variable temporaire (a = b; b = a; => les deux valent b)",
          "Confondre l'adresse et la valeur lors du swap par pointeurs",
          "Ecrire le swap dans le mauvais ordre"
        ]
      },
      {
        "title": "Complexite du tri a bulles",
        "content": "La complexite algorithmique permet de mesurer l'efficacite d'un algorithme. Le tri a bulles a une complexite quadratique O(n²) dans le pire cas et le cas moyen, ce qui le rend lent pour les grands tableaux. Cependant, avec l'optimisation du flag, le meilleur cas devient O(n).",
        "codeExamples": [
          {
            "title": "Comptage des operations",
            "code": "// Pour un tableau de taille n :\n// Passage 1 : n-1 comparaisons\n// Passage 2 : n-2 comparaisons\n// ...\n// Passage n-1 : 1 comparaison\n// Total = (n-1) + (n-2) + ... + 1 = n*(n-1)/2\n// Soit O(n^2)\n\n// Exemple : n = 5\n// Total = 4 + 3 + 2 + 1 = 10 comparaisons\n// n = 100 -> environ 5000 comparaisons\n// n = 1000 -> environ 500 000 comparaisons",
            "explanation": "Le nombre de comparaisons suit la formule n*(n-1)/2, ce qui donne une complexite quadratique"
          }
        ],
        "keyPoints": [
          "Pire cas et cas moyen : O(n²) comparaisons et echanges",
          "Meilleur cas (avec flag) : O(n) si le tableau est deja trie",
          "Complexite en espace : O(1) car le tri est fait en place",
          "Pour n = 1000, on fait environ 500 000 comparaisons"
        ],
        "commonMistakes": [
          "Croire que le bubble sort est efficace pour les grands tableaux",
          "Oublier l'optimisation du flag qui ameliore le meilleur cas",
          "Confondre complexite temporelle et nombre exact d'operations"
        ]
      },
      {
        "title": "Comparaison avec d'autres algorithmes",
        "content": "Le tri a bulles est souvent compare a d'autres algorithmes simples comme le tri par selection et le tri par insertion. Chacun a ses avantages selon le contexte. Le bubble sort est surtout utile pedagogiquement : il est facile a comprendre et a implementer.",
        "codeExamples": [
          {
            "title": "Resume des complexites",
            "code": "// Tri a bulles   : O(n^2) pire, O(n) meilleur (avec flag)\n// Tri selection   : O(n^2) toujours\n// Tri insertion   : O(n^2) pire, O(n) meilleur\n// Tri rapide      : O(n log n) moyen, O(n^2) pire\n// Tri fusion      : O(n log n) toujours\n\n// Le bubble sort est stable : il preserve l'ordre\n// des elements egaux\n// Il est aussi adaptatif (avec flag) : rapide\n// sur les tableaux presque tries",
            "explanation": "Le tri a bulles est le plus lent en pratique mais le plus simple a comprendre"
          }
        ],
        "keyPoints": [
          "Le bubble sort est un tri stable (preserve l'ordre des elements egaux)",
          "Il est adaptatif : performant sur des donnees presque triees",
          "Il est en-place : pas besoin de memoire supplementaire",
          "Il est principalement utilise a des fins pedagogiques"
        ],
        "commonMistakes": [
          "Utiliser le bubble sort en production sur de grands jeux de donnees",
          "Croire que tous les tris en O(n²) sont equivalents en pratique",
          "Ne pas connaitre les alternatives plus efficaces (quicksort, mergesort)"
        ]
      }
    ],
    "prepExercises": [
      {
        "id": 1,
        "title": "Swap de deux entiers",
        "instruction": "Ecris une fonction qui echange deux entiers dans un tableau aux positions i et j.",
        "starterCode": "#include <unistd.h>\n\nvoid\tft_swap_in_tab(int *tab, int i, int j)\n{\n\t// Echange tab[i] et tab[j]\n\t// TON CODE ICI\n}",
        "solution": "void\tft_swap_in_tab(int *tab, int i, int j)\n{\n\tint\ttmp;\n\n\ttmp = tab[i];\n\ttab[i] = tab[j];\n\ttab[j] = tmp;\n}",
        "hint": "Utilise une variable temporaire tmp pour ne pas perdre la premiere valeur.",
        "difficulty": 1
      },
      {
        "id": 2,
        "title": "Comparer deux elements adjacents",
        "instruction": "Ecris un bout de code qui compare tab[j] et tab[j+1] et les echange si tab[j] > tab[j+1].",
        "starterCode": "// tab = {5, 3, 8, 1}, j = 0\nif (/* condition */)\n{\n\t// swap\n}",
        "solution": "if (tab[j] > tab[j + 1])\n{\n\tint tmp = tab[j];\n\ttab[j] = tab[j + 1];\n\ttab[j + 1] = tmp;\n}",
        "hint": "Compare avec > pour un tri croissant, echange avec une variable temporaire.",
        "difficulty": 1
      },
      {
        "id": 3,
        "title": "Un seul passage de bubble sort",
        "instruction": "Ecris une boucle qui fait UN SEUL passage de bubble sort sur un tableau de taille size.",
        "starterCode": "void\tone_pass(int *tab, int size)\n{\n\tint\tj;\n\n\tj = 0;\n\t// Parcours tab et echange les elements adjacents mal ordonnes\n\t// TON CODE ICI\n}",
        "solution": "void\tone_pass(int *tab, int size)\n{\n\tint\tj;\n\tint\ttmp;\n\n\tj = 0;\n\twhile (j < size - 1)\n\t{\n\t\tif (tab[j] > tab[j + 1])\n\t\t{\n\t\t\ttmp = tab[j];\n\t\t\ttab[j] = tab[j + 1];\n\t\t\ttab[j + 1] = tmp;\n\t\t}\n\t\tj++;\n\t}\n}",
        "hint": "Boucle j de 0 a size - 2 (soit while j < size - 1).",
        "difficulty": 2
      },
      {
        "id": 4,
        "title": "Afficher un tableau",
        "instruction": "Ecris une fonction qui affiche un tableau d'entiers separes par des espaces et termine par un retour a la ligne. Utilise ft_putnbr et write.",
        "starterCode": "#include <unistd.h>\n\nvoid\tft_putnbr(int n);\n\nvoid\tft_print_tab(int *tab, int size)\n{\n\t// Affiche tab[0] tab[1] ... tab[size-1]\\n\n\t// TON CODE ICI\n}",
        "solution": "void\tft_print_tab(int *tab, int size)\n{\n\tint\ti;\n\n\ti = 0;\n\twhile (i < size)\n\t{\n\t\tft_putnbr(tab[i]);\n\t\tif (i < size - 1)\n\t\t\twrite(1, \" \", 1);\n\t\ti++;\n\t}\n\twrite(1, \"\\n\", 1);\n}",
        "hint": "Boucle de 0 a size-1, ft_putnbr pour chaque element, espace entre sauf apres le dernier.",
        "difficulty": 1
      },
      {
        "id": 5,
        "title": "Bubble sort complet sans optimisation",
        "instruction": "Ecris le bubble sort complet avec deux boucles imbriquees (sans flag d'arret).",
        "starterCode": "void\tft_bubble_sort(int *tab, int size)\n{\n\tint\ti;\n\tint\tj;\n\t// Deux boucles imbriquees\n\t// TON CODE ICI\n}",
        "solution": "void\tft_bubble_sort(int *tab, int size)\n{\n\tint\ti;\n\tint\tj;\n\tint\ttmp;\n\n\ti = 0;\n\twhile (i < size - 1)\n\t{\n\t\tj = 0;\n\t\twhile (j < size - 1 - i)\n\t\t{\n\t\t\tif (tab[j] > tab[j + 1])\n\t\t\t{\n\t\t\t\ttmp = tab[j];\n\t\t\t\ttab[j] = tab[j + 1];\n\t\t\t\ttab[j + 1] = tmp;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\t}\n}",
        "hint": "Boucle externe i de 0 a size-2, boucle interne j de 0 a size-2-i.",
        "difficulty": 2
      },
      {
        "id": 6,
        "title": "Ajouter le flag swapped",
        "instruction": "Ameliore le bubble sort en ajoutant un flag swapped pour arreter le tri tot si le tableau est deja trie.",
        "starterCode": "void\tft_bubble_sort_opti(int *tab, int size)\n{\n\tint\ti;\n\tint\tj;\n\tint\tswapped;\n\t// Ajoute le flag swapped\n\t// TON CODE ICI\n}",
        "solution": "void\tft_bubble_sort_opti(int *tab, int size)\n{\n\tint\ti;\n\tint\tj;\n\tint\ttmp;\n\tint\tswapped;\n\n\ti = 0;\n\twhile (i < size - 1)\n\t{\n\t\tswapped = 0;\n\t\tj = 0;\n\t\twhile (j < size - 1 - i)\n\t\t{\n\t\t\tif (tab[j] > tab[j + 1])\n\t\t\t{\n\t\t\t\ttmp = tab[j];\n\t\t\t\ttab[j] = tab[j + 1];\n\t\t\t\ttab[j + 1] = tmp;\n\t\t\t\tswapped = 1;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (!swapped)\n\t\t\tbreak ;\n\t\ti++;\n\t}\n}",
        "hint": "Initialise swapped = 0 au debut de chaque passage, met-le a 1 lors d'un swap. Si 0 apres un passage, break.",
        "difficulty": 3
      }
    ]
  },
  "starterCode": "#include <unistd.h>\n\nvoid\tft_putnbr(int n)\n{\n\tchar\tc;\n\n\tif (n == -2147483648)\n\t{\n\t\twrite(1, \"-2147483648\", 11);\n\t\treturn ;\n\t}\n\tif (n < 0)\n\t{\n\t\twrite(1, \"-\", 1);\n\t\tn = -n;\n\t}\n\tif (n >= 10)\n\t\tft_putnbr(n / 10);\n\tc = (n % 10) + '0';\n\twrite(1, &c, 1);\n}\n\nvoid\tft_bubble_sort(int *tab, int size)\n{\n\t// 1. Boucle externe : i de 0 a size - 2\n\t// 2. Boucle interne : j de 0 a size - 2 - i\n\t// 3. Si tab[j] > tab[j+1], swap avec variable temporaire\n\t// TON CODE ICI\n}\n\nint\tmain(void)\n{\n\tint\ttab[] = {5, 3, 8, 1, 9, 2};\n\tint\tsize = 6;\n\tint\ti;\n\n\tft_bubble_sort(tab, size);\n\ti = 0;\n\twhile (i < size)\n\t{\n\t\tft_putnbr(tab[i]);\n\t\twrite(1, \"\\n\", 1);\n\t\ti++;\n\t}\n\treturn (0);\n}",
  "solution": "#include <unistd.h>\n\nvoid\tft_putnbr(int n)\n{\n\tchar\tc;\n\n\tif (n == -2147483648)\n\t{\n\t\twrite(1, \"-2147483648\", 11);\n\t\treturn ;\n\t}\n\tif (n < 0)\n\t{\n\t\twrite(1, \"-\", 1);\n\t\tn = -n;\n\t}\n\tif (n >= 10)\n\t\tft_putnbr(n / 10);\n\tc = (n % 10) + '0';\n\twrite(1, &c, 1);\n}\n\nvoid\tft_bubble_sort(int *tab, int size)\n{\n\tint\ti;\n\tint\tj;\n\tint\ttmp;\n\n\ti = 0;\n\twhile (i < size - 1)\n\t{\n\t\tj = 0;\n\t\twhile (j < size - 1 - i)\n\t\t{\n\t\t\tif (tab[j] > tab[j + 1])\n\t\t\t{\n\t\t\t\ttmp = tab[j];\n\t\t\t\ttab[j] = tab[j + 1];\n\t\t\t\ttab[j + 1] = tmp;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\t}\n}\n\nint\tmain(void)\n{\n\tint\ttab[] = {5, 3, 8, 1, 9, 2};\n\tint\tsize = 6;\n\tint\ti;\n\n\tft_bubble_sort(tab, size);\n\ti = 0;\n\twhile (i < size)\n\t{\n\t\tft_putnbr(tab[i]);\n\t\twrite(1, \"\\n\", 1);\n\t\ti++;\n\t}\n\treturn (0);\n}",
  "hints": [
    "Utilise deux boucles while imbriquees : la boucle externe pour les passages, la boucle interne pour les comparaisons adjacentes.",
    "Pour le swap, utilise une variable temporaire tmp : tmp = tab[j]; tab[j] = tab[j+1]; tab[j+1] = tmp;",
    "La boucle interne va jusqu'a size - 1 - i car les i derniers elements sont deja tries apres i passages."
  ],
  "testCases": [
    {
      "id": 1,
      "description": "Tri d'un tableau de 6 elements",
      "stdin": "",
      "expectedStdout": "1\n2\n3\n5\n8\n9\n",
      "expectedExitCode": 0,
      "visible": true
    },
    {
      "id": 2,
      "description": "Tableau deja trie",
      "stdin": "",
      "expectedStdout": "1\n2\n3\n5\n8\n9\n",
      "expectedExitCode": 0,
      "visible": false
    },
    {
      "id": 3,
      "description": "Tableau avec des valeurs negatives",
      "stdin": "",
      "expectedStdout": "1\n2\n3\n5\n8\n9\n",
      "expectedExitCode": 0,
      "visible": false
    }
  ],
  "constraints": {
    "allowedFunctions": ["write"],
    "forbiddenFunctions": ["printf", "qsort", "puts"],
    "maxExecutionTime": 5000,
    "maxMemory": 128
  },
  "relatedExercises": ["c-day46-ex01-ft-is-sorted", "c-day46-ex02-ft-sort-strings"],
  "resources": [
    {
      "title": "Visualisation du tri a bulles",
      "url": "https://visualgo.net/en/sorting",
      "type": "documentation"
    },
    {
      "title": "Bubble Sort - GeeksforGeeks",
      "url": "https://www.geeksforgeeks.org/bubble-sort/",
      "type": "article"
    }
  ]
}