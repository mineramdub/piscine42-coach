{
  "id": "c-day87-ex01-ft-mergesort",
  "category": "c",
  "day": 87,
  "order": 1,
  "title": "Implementer mergesort",
  "description": "Implemente l'algorithme de tri mergesort (tri fusion). Divise le tableau en deux moities, trie chaque moitie recursivement, puis fusionne les deux moities triees. Mergesort est stable et garantit O(n log n) en pire cas, mais necessite O(n) memoire supplementaire.",
  "difficulty": 5,
  "points": 50,
  "estimatedTime": 45,
  "learningObjectives": [
    "Maitriser les concepts de Implementer mergesort",
    "Implementer ft-mergesort de maniere robuste",
    "Comprendre la complexite et les cas limites",
    "Ecrire du code conforme a la norme 42",
    "Tester exhaustivement l'implementation"
  ],
  "learningContent": {
    "lesson": {
      "introduction": "Cet exercice fait partie du jour 87 de la preparation a la piscine 42. Implemente l'algorithme de tri mergesort (tri fusion). Divise le tableau en deux moities, trie chaque moitie recursivement, puis fusionne les deux moities triees. Mergesort est stable et garantit O(n log n) en pire cas, mais necessite O(n) memoire supplementaire.",
      "steps": [
        {
          "id": 1,
          "title": "Concept fondamental",
          "content": "Introduction au concept principal de Implementer mergesort.",
          "codeExample": "// Exemple introductif\n#include <stdio.h>\n#include <stdlib.h>\n\nint\tmain(void)\n{\n\tprintf(\"Implementer mergesort\\n\");\n\treturn (0);\n}",
          "language": "c",
          "tryItYourself": {
            "instruction": "Question fondamentale sur Implementer mergesort ?",
            "starterCode": "// Debut de reponse pour ft-mergesort...",
            "solution": "// Reponse complete pour ft-mergesort"
          }
        },
        {
          "id": 2,
          "title": "Implementation de base",
          "content": "Les elements de base pour implementer ft-mergesort.",
          "codeExample": "// Implementation de base\nvoid\tft_mergesort(void)\n{\n\t// Logique principale\n\tprintf(\"Implementation de base\\n\");\n}",
          "language": "c",
          "tryItYourself": {
            "instruction": "Question sur l'implementation ?",
            "starterCode": "// Reponse partielle...",
            "solution": "// Reponse complete"
          }
        },
        {
          "id": 3,
          "title": "Cas limites et robustesse",
          "content": "Gerer les cas limites pour Implementer mergesort.",
          "codeExample": "// Gestion des cas limites\nif (!input)\n\treturn (NULL);\nif (size == 0)\n\treturn (NULL);",
          "language": "c",
          "tryItYourself": {
            "instruction": "Quel cas limite est le plus important pour ft-mergesort ?",
            "starterCode": "// Le cas limite principal est...",
            "solution": "// Le cas limite principal est l'entree NULL ou vide"
          }
        },
        {
          "id": 4,
          "title": "Implementation complete et tests",
          "content": "L'implementation complete de ft-mergesort avec des tests.",
          "codeExample": "#include <stdio.h>\n\nint\tmain(void)\n{\n\tprintf(\"Test ft-mergesort OK\\n\");\n\treturn (0);\n}",
          "language": "c"
        }
      ]
    },
    "theory": [
      {
        "title": "Algorithmes de tri : complexite",
        "content": "La complexite d'un algorithme de tri determine sa vitesse pour de grandes quantites de donnees.",
        "codeExamples": [
          {
            "title": "Comparaison des complexites",
            "code": "// Bubble sort : O(n^2) en moyenne et pire\n// Insertion sort : O(n^2) en moyenne, O(n) au meilleur\n// Quicksort : O(n log n) en moyenne, O(n^2) au pire\n// Mergesort : O(n log n) toujours",
            "explanation": "Le choix de l'algorithme depend de la taille des donnees"
          }
        ],
        "keyPoints": [
          "Bubble sort et insertion sort sont O(n^2) en moyenne",
          "Quicksort est O(n log n) en moyenne mais O(n^2) au pire",
          "Mergesort garantit O(n log n) en toutes circonstances",
          "Pour de petits tableaux (< 20), insertion sort est souvent le plus rapide"
        ],
        "commonMistakes": [
          "Croire que quicksort est toujours plus rapide que mergesort",
          "Ignorer la complexite spatiale (mergesort utilise O(n) memoire)",
          "Ne pas considerer la stabilite du tri"
        ]
      },
      {
        "title": "Quicksort : pivot et partition",
        "content": "Le choix du pivot et l'algorithme de partition sont les elements cles de quicksort.",
        "codeExamples": [
          {
            "title": "Algorithme de partition de Lomuto",
            "code": "void partition(int *arr, int lo, int hi)\n{\n\tint pivot = arr[hi];\n\tint i = lo - 1;\n\tfor (int j = lo; j < hi; j++)\n\t\tif (arr[j] <= pivot)\n\t\t\tswap(&arr[++i], &arr[j]);\n\tswap(&arr[i + 1], &arr[hi]);\n}",
            "explanation": "La partition de Lomuto est simple mais pas optimale"
          }
        ],
        "keyPoints": [
          "Le pivot divise le tableau en elements plus petits et plus grands",
          "Le choix du pivot affecte la performance (median of three est recommande)",
          "La partition de Lomuto est simple, celle de Hoare est plus efficace",
          "Le pire cas arrive quand le pivot est toujours le min ou max"
        ],
        "commonMistakes": [
          "Choisir toujours le premier ou dernier element comme pivot",
          "Ne pas gerer les elements egaux au pivot correctement",
          "Oublier le cas de base de la recursion (tableau de taille 0 ou 1)"
        ]
      },
      {
        "title": "Mergesort : diviser pour regner",
        "content": "Mergesort divise le probleme en sous-problemes, les resout recursivement, puis combine les solutions.",
        "codeExamples": [
          {
            "title": "Fusion de deux tableaux tries",
            "code": "void merge(int *arr, int *tmp, int lo, int mid, int hi)\n{\n\tint i = lo, j = mid + 1, k = lo;\n\twhile (i <= mid && j <= hi)\n\t{\n\t\tif (arr[i] <= arr[j])\n\t\t\ttmp[k++] = arr[i++];\n\t\telse\n\t\t\ttmp[k++] = arr[j++];\n\t}\n\twhile (i <= mid) tmp[k++] = arr[i++];\n\twhile (j <= hi) tmp[k++] = arr[j++];\n}",
            "explanation": "La fusion est l'etape cle : elle combine deux sous-tableaux tries en un seul"
          }
        ],
        "keyPoints": [
          "La fusion de deux tableaux tries est O(n)",
          "Mergesort divise toujours en deux moities egales",
          "Il necessite un tableau temporaire de taille n",
          "Il est stable : les elements egaux gardent leur ordre relatif"
        ],
        "commonMistakes": [
          "Oublier de copier le tableau temporaire dans le tableau original",
          "Allouer un nouveau tableau temporaire a chaque appel recursif",
          "Ne pas gerer le cas ou un sous-tableau est vide"
        ]
      },
      {
        "title": "Benchmark et mesure de performance",
        "content": "Mesurer les performances reelles permet de valider les analyses theoriques de complexite.",
        "codeExamples": [
          {
            "title": "Mesurer le temps avec clock()",
            "code": "#include <time.h>\nclock_t start = clock();\n// ... algorithme ...\nclock_t end = clock();\ndouble time = (double)(end - start) / CLOCKS_PER_SEC;\nprintf(\"Temps : %.6f s\\n\", time);",
            "explanation": "clock() mesure le temps CPU utilise par le programme"
          }
        ],
        "keyPoints": [
          "clock() mesure le temps CPU, time() mesure le temps reel",
          "CLOCKS_PER_SEC convertit les clocks en secondes",
          "Faire plusieurs mesures et prendre la moyenne",
          "Tester avec des tailles croissantes pour verifier la complexite"
        ],
        "commonMistakes": [
          "Mesurer sur des tableaux trop petits (pas representatif)",
          "Compiler sans optimisation (les resultats seraient differents)",
          "Ne pas reinitialiser le tableau entre les tests"
        ]
      }
    ],
    "prepExercises": [
      {
        "id": 1,
        "title": "Exercice preparatoire 1",
        "instruction": "Ecris une fonction utilitaire pour Implementer mergesort.",
        "starterCode": "void\tft_helper_1(void)\n{\n\t// A completer\n}",
        "solution": "void\tft_helper_1(void)\n{\n\tprintf(\"Helper 1\\n\");\n}",
        "hint": "Indice pour l'exercice preparatoire 1",
        "difficulty": 1
      },
      {
        "id": 2,
        "title": "Exercice preparatoire 2",
        "instruction": "Implemente un composant de ft-mergesort.",
        "starterCode": "int\tft_helper_2(int n)\n{\n\t// A completer\n}",
        "solution": "int\tft_helper_2(int n)\n{\n\treturn (n * 2);\n}",
        "hint": "Indice pour l'exercice preparatoire 2",
        "difficulty": 2
      },
      {
        "id": 3,
        "title": "Exercice preparatoire 3",
        "instruction": "Teste ta comprehension de Implementer mergesort.",
        "starterCode": "int\tft_helper_3(char *str)\n{\n\t// A completer\n}",
        "solution": "int\tft_helper_3(char *str)\n{\n\tint i = 0;\n\twhile (str[i])\n\t\ti++;\n\treturn (i);\n}",
        "hint": "Indice pour l'exercice preparatoire 3",
        "difficulty": 2
      },
      {
        "id": 4,
        "title": "Exercice preparatoire 4",
        "instruction": "Pratique avancee pour ft-mergesort.",
        "starterCode": "void\tft_helper_4(int *arr, int n)\n{\n\t// A completer\n}",
        "solution": "void\tft_helper_4(int *arr, int n)\n{\n\tint i = 0;\n\twhile (i < n)\n\t\tprintf(\"%d \", arr[i++]);\n\tprintf(\"\\n\");\n}",
        "hint": "Indice pour l'exercice preparatoire 4",
        "difficulty": 2
      },
      {
        "id": 5,
        "title": "Exercice preparatoire 5",
        "instruction": "Combine les concepts pour Implementer mergesort.",
        "starterCode": "int\tft_helper_5(void)\n{\n\t// A completer\n}",
        "solution": "int\tft_helper_5(void)\n{\n\treturn (42);\n}",
        "hint": "Indice pour l'exercice preparatoire 5",
        "difficulty": 3
      }
    ]
  },
  "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint\tmain(void)\n{\n\tprintf(\"Test ft-mergesort\\n\");\n\treturn (0);\n}",
  "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint\tmain(void)\n{\n\tprintf(\"Test ft-mergesort\\n\");\n\treturn (0);\n}",
  "hints": [
    "Indice 1 : commence par decomposer Implementer mergesort en sous-problemes",
    "Indice 2 : n'oublie pas les cas limites (NULL, taille 0)",
    "Indice 3 : teste avec des exemples simples avant les cas complexes"
  ],
  "testCases": [
    {
      "id": 1,
      "description": "Test basique de ft-mergesort",
      "stdin": "",
      "expectedStdout": "Test ft-mergesort\n",
      "expectedExitCode": 0,
      "visible": true
    },
    {
      "id": 2,
      "description": "Test avance de ft-mergesort",
      "stdin": "",
      "expectedStdout": "Test ft-mergesort\n",
      "expectedExitCode": 0,
      "visible": false
    },
    {
      "id": 3,
      "description": "Test cas limite de ft-mergesort",
      "stdin": "",
      "expectedStdout": "Test ft-mergesort\n",
      "expectedExitCode": 0,
      "visible": false
    }
  ],
  "constraints": {
    "allowedFunctions": [
      "malloc",
      "free",
      "write",
      "printf",
      "open",
      "close",
      "read"
    ],
    "forbiddenFunctions": [
      "system"
    ],
    "maxExecutionTime": 5000,
    "maxMemory": 128
  },
  "relatedExercises": [
    "c-day87-ex02-ft-sort-compare",
    "c-day87-ex00-ft-quicksort"
  ],
  "resources": [
    {
      "title": "Documentation Implementer mergesort",
      "url": "https://www.geeksforgeeks.org/c-programming-language/",
      "type": "documentation"
    },
    {
      "title": "Tutoriel Implementer mergesort",
      "url": "https://www.programiz.com/c-programming",
      "type": "article"
    }
  ]
}