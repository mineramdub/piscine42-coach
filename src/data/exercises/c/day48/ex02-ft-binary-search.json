{
  "id": "c-day48-ex02-ft-binary-search",
  "category": "c",
  "day": 48,
  "order": 2,
  "title": "Recherche dichotomique (Binary Search)",
  "description": "Ecris une fonction ft_binary_search(int *tab, int size, int target) qui cherche la valeur target dans un tableau trie par ordre croissant. Retourne l'indice de target si trouve, ou -1 si absent. Utilise l'algorithme de recherche dichotomique (diviser l'espace de recherche en deux a chaque etape). Prototype : int ft_binary_search(int *tab, int size, int target);",
  "difficulty": 4,
  "points": 40,
  "estimatedTime": 40,
  "learningObjectives": [
    "Comprendre le principe de la recherche dichotomique",
    "Implementer un algorithme en O(log n)",
    "Comparer la recherche lineaire O(n) et la recherche binaire O(log n)",
    "Maitriser la gestion des bornes low, high et mid",
    "Comprendre la pre-condition de tableau trie"
  ],
  "learningContent": {
    "lesson": {
      "introduction": "La recherche dichotomique (binary search) est l'un des algorithmes les plus elegants et efficaces en informatique. Elle permet de trouver un element dans un tableau trie en O(log n), ce qui est considerablement plus rapide que la recherche lineaire en O(n). Le principe est simple : a chaque etape, on compare l'element cherche avec l'element au milieu du tableau. S'il est plus petit, on cherche dans la moitie gauche. S'il est plus grand, on cherche dans la moitie droite. On divise ainsi l'espace de recherche par deux a chaque iteration.",
      "steps": [
        {
          "id": 1,
          "title": "Le principe : diviser pour regner",
          "content": "La recherche binaire fonctionne sur un **tableau trie**. Le principe est :\n\n1. Regarder l'element au **milieu** du tableau\n2. Si c'est la valeur cherchee, on a trouve !\n3. Si la valeur cherchee est **plus petite**, chercher dans la **moitie gauche**\n4. Si la valeur cherchee est **plus grande**, chercher dans la **moitie droite**\n5. Repeter jusqu'a trouver ou epuiser l'espace de recherche\n\n**Analogie :** C'est comme chercher un mot dans un dictionnaire. Tu ne lis pas page par page. Tu ouvres au milieu, et selon que le mot est avant ou apres, tu continues dans la bonne moitie.",
          "codeExample": "// Chercher 7 dans {1, 3, 5, 7, 9, 11, 13}\n// low=0, high=6, mid=3 -> tab[3]=7 == 7 -> TROUVE !\n\n// Chercher 3 dans {1, 3, 5, 7, 9, 11, 13}\n// low=0, high=6, mid=3 -> tab[3]=7 > 3 -> gauche\n// low=0, high=2, mid=1 -> tab[1]=3 == 3 -> TROUVE !\n\n// Chercher 6 dans {1, 3, 5, 7, 9, 11, 13}\n// low=0, high=6, mid=3 -> tab[3]=7 > 6 -> gauche\n// low=0, high=2, mid=1 -> tab[1]=3 < 6 -> droite\n// low=2, high=2, mid=2 -> tab[2]=5 < 6 -> droite\n// low=3, high=2 -> low > high -> PAS TROUVE (-1)",
          "language": "c",
          "tryItYourself": {
            "instruction": "Cherche la valeur 11 dans le tableau {2, 4, 6, 8, 10, 12, 14}. Combien d'etapes faut-il ?",
            "starterCode": "// tab = {2, 4, 6, 8, 10, 12, 14}, target = 11\n// Etape 1 : low=0, high=6, mid=3 -> tab[3]=8\n//   8 < 11 -> chercher a ???\n// Etape 2 : low=???, high=???, mid=???\n//   tab[mid]=??? -> ???\n// ...",
            "solution": "// Etape 1 : low=0, high=6, mid=3 -> tab[3]=8\n//   8 < 11 -> chercher a droite\n// Etape 2 : low=4, high=6, mid=5 -> tab[5]=12\n//   12 > 11 -> chercher a gauche\n// Etape 3 : low=4, high=4, mid=4 -> tab[4]=10\n//   10 < 11 -> chercher a droite\n// Etape 4 : low=5, high=4 -> low > high -> PAS TROUVE\n// 11 n'est pas dans le tableau, retourne -1"
          }
        },
        {
          "id": 2,
          "title": "Les variables low, high et mid",
          "content": "L'algorithme utilise trois variables pour definir l'espace de recherche :\n\n- **low** : borne inferieure (debut de la zone de recherche)\n- **high** : borne superieure (fin de la zone de recherche)\n- **mid** : indice du milieu, calcule a chaque iteration\n\n**Calcul de mid :** `mid = (low + high) / 2`\n\n**Mise a jour des bornes :**\n- Si target < tab[mid] : high = mid - 1 (chercher a gauche)\n- Si target > tab[mid] : low = mid + 1 (chercher a droite)\n- Si target == tab[mid] : retourner mid (trouve !)\n\n**Condition d'arret :** low > high signifie que l'espace de recherche est vide.",
          "codeExample": "int\tft_binary_search(int *tab, int size, int target)\n{\n\tint\tlow;\n\tint\thigh;\n\tint\tmid;\n\n\tlow = 0;\n\thigh = size - 1;\n\twhile (low <= high)\n\t{\n\t\tmid = (low + high) / 2;\n\t\tif (tab[mid] == target)\n\t\t\treturn (mid);\n\t\telse if (tab[mid] < target)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\treturn (-1);\n}",
          "language": "c",
          "tryItYourself": {
            "instruction": "Si low = 3 et high = 9, quel est mid ? Si tab[mid] > target, quelles sont les nouvelles bornes ?",
            "starterCode": "// low = 3, high = 9\n// mid = (3 + 9) / 2 = ???\n// Si tab[mid] > target :\n//   low = ???\n//   high = ???",
            "solution": "// low = 3, high = 9\n// mid = (3 + 9) / 2 = 6\n// Si tab[mid] > target (chercher a gauche) :\n//   low = 3 (inchange)\n//   high = mid - 1 = 5\n// Nouvel espace : [3, 5]"
          }
        },
        {
          "id": 3,
          "title": "Complexite O(log n)",
          "content": "La recherche binaire a une complexite de O(log n) car a chaque iteration, l'espace de recherche est divise par deux.\n\n**Pourquoi log n ?** Si on a n elements :\n- Apres 1 iteration : n/2 elements restants\n- Apres 2 iterations : n/4 elements\n- Apres k iterations : n/2^k elements\n- On s'arrete quand n/2^k = 1, soit k = log2(n)\n\n**Exemples concrets :**\n- n = 1000 -> max 10 iterations\n- n = 1 000 000 -> max 20 iterations\n- n = 1 000 000 000 -> max 30 iterations\n\nMeme dans un tableau de **1 milliard** d'elements, on trouve la valeur en au plus 30 comparaisons !",
          "codeExample": "// Comparaison : recherche lineaire vs binaire\n// n = 1000 :\n//   Lineaire : jusqu'a 1000 comparaisons\n//   Binaire  : max 10 comparaisons\n\n// n = 1 000 000 :\n//   Lineaire : jusqu'a 1 000 000 comparaisons\n//   Binaire  : max 20 comparaisons\n\n// n = 1 000 000 000 :\n//   Lineaire : jusqu'a 1 000 000 000 comparaisons\n//   Binaire  : max 30 comparaisons !\n\n// log2(1000) ~= 10\n// log2(1000000) ~= 20\n// log2(1000000000) ~= 30",
          "language": "c",
          "tryItYourself": {
            "instruction": "Combien d'iterations maximum faut-il pour une recherche binaire dans un tableau de 1024 elements ?",
            "starterCode": "// n = 1024\n// 1024 / 2 = 512 (iteration 1)\n// 512 / 2 = 256  (iteration 2)\n// ...\n// Combien d'iterations pour arriver a 1 ?\n// log2(1024) = ???",
            "solution": "// 1024 -> 512 -> 256 -> 128 -> 64 -> 32 -> 16 -> 8 -> 4 -> 2 -> 1\n// 10 divisions par 2\n// log2(1024) = 10\n// Maximum 10 iterations (+ 1 pour verifier) = 11"
          }
        },
        {
          "id": 4,
          "title": "Pre-condition et cas limites",
          "content": "La recherche binaire **necessite un tableau trie**. C'est une pre-condition essentielle. Si le tableau n'est pas trie, le resultat est imprevisible.\n\n**Cas limites a gerer :**\n1. Tableau vide (size = 0) : retourner -1\n2. Element au debut : trouve a la premiere ou deuxieme iteration\n3. Element a la fin : trouve en O(log n) iterations\n4. Element absent : la boucle se termine quand low > high\n5. Doublons : retourne l'indice d'un des elements (pas forcement le premier)\n\n**Piege du overflow :** `mid = (low + high) / 2` peut provoquer un overflow si low + high depasse INT_MAX. La version sure est `mid = low + (high - low) / 2`.",
          "codeExample": "// Version sure (pas d'overflow) :\nmid = low + (high - low) / 2;\n// Equivalent a (low + high) / 2 mais sans risque\n\n// Cas limites :\n// size = 0 : high = -1, low (0) > high (-1) -> return -1\n// Debut : mid va vite converger vers 0\n// Fin : mid va vite converger vers size - 1\n\n// Le tableau DOIT etre trie !\n// Sur un tableau non trie, binary search peut :\n// - Ne pas trouver un element qui est present\n// - Retourner un mauvais indice",
          "language": "c"
        }
      ]
    },
    "theory": [
      {
        "title": "Diviser pour regner",
        "content": "La recherche binaire est un exemple du paradigme 'diviser pour regner' (divide and conquer). On divise le probleme en sous-problemes plus petits, on resout les sous-problemes, et on combine les solutions.",
        "codeExamples": [
          {
            "title": "Le paradigme diviser pour regner",
            "code": "// Diviser pour regner en 3 etapes :\n// 1. DIVISER : couper le probleme en deux\n// 2. REGNER  : resoudre sur la moitie pertinente\n// 3. COMBINER : (pas de combinaison pour la recherche)\n\n// Binary search :\n// 1. DIVISER : trouver mid = (low + high) / 2\n// 2. REGNER  : chercher dans [low, mid-1] ou [mid+1, high]\n// 3. COMBINER : retourner l'indice directement\n\n// Autres algorithmes diviser pour regner :\n// - Merge sort (tri fusion)\n// - Quicksort (tri rapide)\n// - Exponentiation rapide",
            "explanation": "Diviser le probleme en deux a chaque etape donne une complexite logarithmique"
          }
        ],
        "keyPoints": [
          "On divise l'espace de recherche en deux a chaque etape",
          "La complexite est O(log n) car on fait log2(n) divisions",
          "C'est l'un des paradigmes les plus puissants en algorithmique",
          "La pre-condition est que les donnees soient triees"
        ],
        "commonMistakes": [
          "Appliquer la recherche binaire sur des donnees non triees",
          "Oublier de mettre a jour correctement low et high",
          "Utiliser mid - 1 et mid + 1 au lieu de juste mid (boucle infinie)"
        ]
      },
      {
        "title": "Le logarithme en informatique",
        "content": "Le logarithme en base 2 (log2) est fondamental en informatique car de nombreux algorithmes divisent leur probleme en deux. log2(n) est le nombre de fois qu'on peut diviser n par 2 avant d'atteindre 1.",
        "codeExamples": [
          {
            "title": "Valeurs utiles de log2",
            "code": "// log2(1) = 0     (2^0 = 1)\n// log2(2) = 1     (2^1 = 2)\n// log2(4) = 2     (2^2 = 4)\n// log2(8) = 3     (2^3 = 8)\n// log2(16) = 4    (2^4 = 16)\n// log2(32) = 5    (2^5 = 32)\n// log2(64) = 6    (2^6 = 64)\n// log2(128) = 7   (2^7 = 128)\n// log2(256) = 8   (2^8 = 256)\n// log2(1024) = 10 (2^10 = 1024)\n// log2(1000000) ~= 20\n\n// En gros : log2(n) = nombre de bits pour ecrire n\n// Un int de 32 bits peut stocker 2^32 = ~4 milliards\n// -> log2(4 milliards) = 32 iterations max !",
            "explanation": "Le logarithme croit tres lentement, ce qui rend les algorithmes O(log n) extremement rapides"
          }
        ],
        "keyPoints": [
          "log2(n) = nombre de divisions par 2 pour atteindre 1",
          "log2 croit tres lentement : log2(1 million) = ~20",
          "En Big O, la base du log n'importe pas (car log_a(n) = log_b(n) * constante)",
          "O(log n) est presque aussi rapide que O(1) pour les tailles pratiques"
        ],
        "commonMistakes": [
          "Confondre log n et n (log n est BEAUCOUP plus petit)",
          "Croire que log2 et log10 font une difference en Big O (non)",
          "Oublier que log n croit si lentement que c'est quasi-constant en pratique"
        ]
      },
      {
        "title": "Recherche lineaire vs recherche binaire",
        "content": "La recherche lineaire parcourt le tableau element par element en O(n). La recherche binaire divise l'espace par deux en O(log n). Le gain est enorme pour les grands tableaux.",
        "codeExamples": [
          {
            "title": "Comparaison des deux approches",
            "code": "// Recherche lineaire : O(n)\nint\tlinear_search(int *tab, int size, int target)\n{\n\tint i = 0;\n\twhile (i < size)\n\t{\n\t\tif (tab[i] == target)\n\t\t\treturn (i);\n\t\ti++;\n\t}\n\treturn (-1);\n}\n\n// Recherche binaire : O(log n)\nint\tbinary_search(int *tab, int size, int target)\n{\n\tint low = 0;\n\tint high = size - 1;\n\twhile (low <= high)\n\t{\n\t\tint mid = (low + high) / 2;\n\t\tif (tab[mid] == target) return (mid);\n\t\telse if (tab[mid] < target) low = mid + 1;\n\t\telse high = mid - 1;\n\t}\n\treturn (-1);\n}",
            "explanation": "La recherche lineaire fonctionne sur tout tableau, la binaire uniquement sur les tableaux tries"
          }
        ],
        "keyPoints": [
          "Lineaire : O(n), fonctionne sur tout tableau",
          "Binaire : O(log n), necessite un tableau trie",
          "Pour n = 1 million, lineaire = 1M ops, binaire = 20 ops",
          "Si on cherche souvent, il vaut mieux trier puis chercher en binaire"
        ],
        "commonMistakes": [
          "Utiliser la recherche lineaire sur un tableau trie (gaspillage)",
          "Utiliser la recherche binaire sur un tableau non trie (resultats faux)",
          "Ne pas considerer le cout du tri si on fait peu de recherches"
        ]
      },
      {
        "title": "Erreurs classiques du binary search",
        "content": "Le binary search est simple en theorie mais piege en pratique. De nombreux programmeurs experimenters font des erreurs dans l'implementation, notamment sur les bornes et la condition d'arret.",
        "codeExamples": [
          {
            "title": "Les pieges classiques",
            "code": "// PIEGE 1 : condition d'arret\nwhile (low < high)     // FAUX : manque le cas low == high\nwhile (low <= high)    // CORRECT\n\n// PIEGE 2 : mise a jour des bornes\nhigh = mid;            // RISQUE de boucle infinie\nhigh = mid - 1;        // CORRECT\nlow = mid;             // RISQUE de boucle infinie\nlow = mid + 1;         // CORRECT\n\n// PIEGE 3 : overflow du calcul de mid\nmid = (low + high) / 2;           // Overflow possible\nmid = low + (high - low) / 2;     // Toujours correct\n\n// PIEGE 4 : tableau non trie\n// La recherche binaire SUPPOSE le tableau trie\n// Resultat imprevisible sinon",
            "explanation": "Ces erreurs subtiles causent des bugs difficiles a detecter"
          }
        ],
        "keyPoints": [
          "Toujours utiliser <= dans la condition de boucle",
          "Toujours utiliser mid + 1 et mid - 1 pour eviter les boucles infinies",
          "Preferer low + (high - low) / 2 pour eviter l'overflow",
          "Toujours s'assurer que le tableau est trie avant la recherche"
        ],
        "commonMistakes": [
          "Utiliser < au lieu de <= (ne trouve pas l'element quand low == high)",
          "Utiliser mid au lieu de mid +/- 1 (boucle infinie)",
          "Ne pas gerer le cas ou l'element n'est pas dans le tableau"
        ]
      }
    ],
    "prepExercises": [
      {
        "id": 1,
        "title": "Recherche lineaire",
        "instruction": "Ecris une recherche lineaire qui retourne l'indice de target ou -1.",
        "starterCode": "int\tft_linear_search(int *tab, int size, int target)\n{\n\t// Parcours simple de 0 a size - 1\n\t// TON CODE ICI\n}",
        "solution": "int\tft_linear_search(int *tab, int size, int target)\n{\n\tint\ti;\n\n\ti = 0;\n\twhile (i < size)\n\t{\n\t\tif (tab[i] == target)\n\t\t\treturn (i);\n\t\ti++;\n\t}\n\treturn (-1);\n}",
        "hint": "Parcours classique avec return i quand tab[i] == target.",
        "difficulty": 1
      },
      {
        "id": 2,
        "title": "Trouver le milieu",
        "instruction": "Calcule mid a partir de low et high, et affiche-le.",
        "starterCode": "int low = 0;\nint high = 10;\nint mid;\n// Calcule mid\n// TON CODE ICI\n// mid devrait valoir 5",
        "solution": "int low = 0;\nint high = 10;\nint mid = low + (high - low) / 2;\n// mid = 0 + (10 - 0) / 2 = 5",
        "hint": "mid = low + (high - low) / 2 ou mid = (low + high) / 2.",
        "difficulty": 1
      },
      {
        "id": 3,
        "title": "Mettre a jour les bornes",
        "instruction": "Ecris le code qui met a jour low ou high selon la comparaison de tab[mid] avec target.",
        "starterCode": "// tab[mid] = 7, target = 3\nif (tab[mid] == target)\n\t// trouve\nelse if (tab[mid] < target)\n\t// TON CODE ICI\nelse\n\t// TON CODE ICI",
        "solution": "if (tab[mid] == target)\n\treturn (mid);\nelse if (tab[mid] < target)\n\tlow = mid + 1;\nelse\n\thigh = mid - 1;",
        "hint": "Si tab[mid] < target, on cherche a droite : low = mid + 1. Sinon, high = mid - 1.",
        "difficulty": 2
      },
      {
        "id": 4,
        "title": "Binary search iteratif",
        "instruction": "Ecris ft_binary_search complet avec la boucle while.",
        "starterCode": "int\tft_binary_search(int *tab, int size, int target)\n{\n\tint\tlow;\n\tint\thigh;\n\tint\tmid;\n\n\t// TON CODE ICI\n}",
        "solution": "int\tft_binary_search(int *tab, int size, int target)\n{\n\tint\tlow;\n\tint\thigh;\n\tint\tmid;\n\n\tlow = 0;\n\thigh = size - 1;\n\twhile (low <= high)\n\t{\n\t\tmid = low + (high - low) / 2;\n\t\tif (tab[mid] == target)\n\t\t\treturn (mid);\n\t\telse if (tab[mid] < target)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\treturn (-1);\n}",
        "hint": "while (low <= high), calcule mid, compare, met a jour low ou high.",
        "difficulty": 2
      },
      {
        "id": 5,
        "title": "Tester la recherche binaire",
        "instruction": "Ecris un main qui teste ft_binary_search sur un tableau trie.",
        "starterCode": "#include <unistd.h>\n\nvoid\tft_putnbr(int n);\nint\tft_binary_search(int *tab, int size, int target);\n\nint\tmain(void)\n{\n\tint tab[] = {1, 3, 5, 7, 9, 11, 13};\n\t// Cherche 7 (present) et 6 (absent)\n\t// TON CODE ICI\n\treturn (0);\n}",
        "solution": "#include <unistd.h>\n\nvoid\tft_putnbr(int n);\nint\tft_binary_search(int *tab, int size, int target);\n\nint\tmain(void)\n{\n\tint tab[] = {1, 3, 5, 7, 9, 11, 13};\n\n\tft_putnbr(ft_binary_search(tab, 7, 7));\n\twrite(1, \"\\n\", 1);\n\tft_putnbr(ft_binary_search(tab, 7, 6));\n\twrite(1, \"\\n\", 1);\n\t// Affiche 3 puis -1\n\treturn (0);\n}",
        "hint": "ft_binary_search(tab, 7, 7) doit retourner 3 (indice de 7). Pour 6, retourne -1.",
        "difficulty": 1
      }
    ]
  },
  "starterCode": "#include <unistd.h>\n\nvoid\tft_putnbr(int n)\n{\n\tchar\tc;\n\n\tif (n == -2147483648)\n\t{\n\t\twrite(1, \"-2147483648\", 11);\n\t\treturn ;\n\t}\n\tif (n < 0)\n\t{\n\t\twrite(1, \"-\", 1);\n\t\tn = -n;\n\t}\n\tif (n >= 10)\n\t\tft_putnbr(n / 10);\n\tc = (n % 10) + '0';\n\twrite(1, &c, 1);\n}\n\nint\tft_binary_search(int *tab, int size, int target)\n{\n\t// 1. Initialise low = 0 et high = size - 1\n\t// 2. Tant que low <= high :\n\t//    a. mid = (low + high) / 2\n\t//    b. Si tab[mid] == target : return mid\n\t//    c. Si tab[mid] < target : low = mid + 1\n\t//    d. Sinon : high = mid - 1\n\t// 3. Return -1 (pas trouve)\n\t// TON CODE ICI\n}\n\nint\tmain(void)\n{\n\tint\ttab[] = {2, 5, 8, 12, 16, 23, 38, 42, 56, 72};\n\n\tft_putnbr(ft_binary_search(tab, 10, 23));\n\twrite(1, \"\\n\", 1);\n\tft_putnbr(ft_binary_search(tab, 10, 2));\n\twrite(1, \"\\n\", 1);\n\tft_putnbr(ft_binary_search(tab, 10, 72));\n\twrite(1, \"\\n\", 1);\n\tft_putnbr(ft_binary_search(tab, 10, 15));\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}",
  "solution": "#include <unistd.h>\n\nvoid\tft_putnbr(int n)\n{\n\tchar\tc;\n\n\tif (n == -2147483648)\n\t{\n\t\twrite(1, \"-2147483648\", 11);\n\t\treturn ;\n\t}\n\tif (n < 0)\n\t{\n\t\twrite(1, \"-\", 1);\n\t\tn = -n;\n\t}\n\tif (n >= 10)\n\t\tft_putnbr(n / 10);\n\tc = (n % 10) + '0';\n\twrite(1, &c, 1);\n}\n\nint\tft_binary_search(int *tab, int size, int target)\n{\n\tint\tlow;\n\tint\thigh;\n\tint\tmid;\n\n\tlow = 0;\n\thigh = size - 1;\n\twhile (low <= high)\n\t{\n\t\tmid = low + (high - low) / 2;\n\t\tif (tab[mid] == target)\n\t\t\treturn (mid);\n\t\telse if (tab[mid] < target)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\treturn (-1);\n}\n\nint\tmain(void)\n{\n\tint\ttab[] = {2, 5, 8, 12, 16, 23, 38, 42, 56, 72};\n\n\tft_putnbr(ft_binary_search(tab, 10, 23));\n\twrite(1, \"\\n\", 1);\n\tft_putnbr(ft_binary_search(tab, 10, 2));\n\twrite(1, \"\\n\", 1);\n\tft_putnbr(ft_binary_search(tab, 10, 72));\n\twrite(1, \"\\n\", 1);\n\tft_putnbr(ft_binary_search(tab, 10, 15));\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}",
  "hints": [
    "Initialise low = 0 et high = size - 1. La boucle continue tant que low <= high (attention au = !).",
    "Calcule mid = low + (high - low) / 2 pour eviter l'overflow. Compare tab[mid] avec target.",
    "Si tab[mid] < target, cherche a droite : low = mid + 1. Sinon, cherche a gauche : high = mid - 1."
  ],
  "testCases": [
    {
      "id": 1,
      "description": "Recherche de valeurs presentes et absentes",
      "stdin": "",
      "expectedStdout": "5\n0\n9\n-1\n",
      "expectedExitCode": 0,
      "visible": true
    },
    {
      "id": 2,
      "description": "Element au debut et a la fin",
      "stdin": "",
      "expectedStdout": "5\n0\n9\n-1\n",
      "expectedExitCode": 0,
      "visible": false
    },
    {
      "id": 3,
      "description": "Tableau de taille 1",
      "stdin": "",
      "expectedStdout": "5\n0\n9\n-1\n",
      "expectedExitCode": 0,
      "visible": false
    }
  ],
  "constraints": {
    "allowedFunctions": ["write"],
    "forbiddenFunctions": ["printf", "bsearch", "puts"],
    "maxExecutionTime": 5000,
    "maxMemory": 128
  },
  "relatedExercises": ["c-day48-ex00-ft-count-ops", "c-day48-ex01-ft-is-big-o-n2"],
  "resources": [
    {
      "title": "Binary Search - Visualisation",
      "url": "https://www.cs.usfca.edu/~galles/visualization/Search.html",
      "type": "documentation"
    },
    {
      "title": "Recherche dichotomique - GeeksforGeeks",
      "url": "https://www.geeksforgeeks.org/binary-search/",
      "type": "article"
    }
  ]
}