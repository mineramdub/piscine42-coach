{
  "id": "c-day57-ex02-ft-mini-pipex",
  "category": "c",
  "day": 57,
  "order": 2,
  "title": "Mini pipex : executer cmd1 | cmd2",
  "description": "Ecris un programme qui prend 4 arguments : fichier_in cmd1 cmd2 fichier_out. Il doit reproduire le comportement de '< fichier_in cmd1 | cmd2 > fichier_out'. Le programme lit depuis fichier_in, passe les donnees a cmd1 via stdin, pipe la sortie de cmd1 vers cmd2, et ecrit le resultat de cmd2 dans fichier_out. Les commandes sont des chaines simples (un seul mot, sans arguments).",
  "difficulty": 5,
  "points": 50,
  "estimatedTime": 45,
  "learningObjectives": [
    "Implementer un mini pipex combinant redirections et pipe",
    "Maitriser l'ouverture de fichiers avec open() pour les redirections",
    "Comprendre le flux complet : fichier -> cmd1 -> pipe -> cmd2 -> fichier",
    "Gerer les erreurs de fichiers, fork, pipe et execve",
    "Preparer le projet pipex de 42"
  ],
  "learningContent": {
    "lesson": {
      "introduction": "Le projet pipex de 42 demande de reproduire le comportement de '< infile cmd1 | cmd2 > outfile'. Ce mini-exercice simplifie le probleme en ne gerant que des commandes sans arguments. Le flux est : lire depuis un fichier d'entree, passer les donnees a la premiere commande, piper sa sortie vers la seconde commande, et ecrire le resultat dans un fichier de sortie. C'est la combinaison de tout ce que nous avons appris : open, fork, pipe, dup2 et execve.",
      "steps": [
        {
          "id": 1,
          "title": "Le flux de donnees dans pipex",
          "content": "Le comportement a reproduire est :\n`< infile cmd1 | cmd2 > outfile`\n\nCela signifie :\n1. **infile** est redirige vers stdin de **cmd1**\n2. La sortie de **cmd1** est pipee vers stdin de **cmd2**\n3. La sortie de **cmd2** est redirigee vers **outfile**\n\n**Schema :**\n```\ninfile -> [cmd1] -> [PIPE] -> [cmd2] -> outfile\n```\n\nOn a besoin de 2 fork (un pour chaque commande) et 1 pipe.",
          "codeExample": "// Equivalent shell :\n// < infile cmd1 | cmd2 > outfile\n//\n// Decomposition :\n// Fils 1 : stdin <- infile, stdout -> pipe\n//          execve(cmd1)\n// Fils 2 : stdin <- pipe, stdout -> outfile\n//          execve(cmd2)\n//\n// Appels systeme necessaires :\n// open()   - ouvrir infile et outfile\n// pipe()   - creer le canal entre cmd1 et cmd2\n// fork()   - creer les 2 processus fils\n// dup2()   - rediriger stdin/stdout\n// execve() - lancer les commandes\n// close()  - fermer les descripteurs\n// wait()   - attendre les fils",
          "language": "c",
          "tryItYourself": {
            "instruction": "Pour 'cat < input.txt | grep hello > output.txt', quelles redirections fait chaque fils ?",
            "starterCode": "// Fils 1 (cat) :\n//   stdin <- ???\n//   stdout -> ???\n// Fils 2 (grep hello) :\n//   stdin <- ???\n//   stdout -> ???",
            "solution": "// Fils 1 (cat) :\n//   stdin <- input.txt (dup2(fd_in, 0))\n//   stdout -> pipe (dup2(fd[1], 1))\n// Fils 2 (grep hello) :\n//   stdin <- pipe (dup2(fd[0], 0))\n//   stdout -> output.txt (dup2(fd_out, 1))"
          }
        },
        {
          "id": 2,
          "title": "Ouvrir les fichiers d'entree et de sortie",
          "content": "On utilise **open()** pour ouvrir les fichiers :\n- **infile** : ouvert en lecture seule (O_RDONLY)\n- **outfile** : ouvert en ecriture, cree s'il n'existe pas, tronque s'il existe (O_WRONLY | O_CREAT | O_TRUNC)\n\nLes permissions de creation sont typiquement 0644 (rw-r--r--).",
          "codeExample": "#include <fcntl.h>\n#include <unistd.h>\n\nint\tmain(int argc, char **argv)\n{\n\tint fd_in;\n\tint fd_out;\n\n\t// Ouvrir le fichier d'entree\n\tfd_in = open(argv[1], O_RDONLY);\n\tif (fd_in == -1)\n\t{\n\t\twrite(2, \"Erreur infile\\n\", 14);\n\t\treturn (1);\n\t}\n\t// Ouvrir/creer le fichier de sortie\n\tfd_out = open(argv[4], O_WRONLY | O_CREAT | O_TRUNC, 0644);\n\tif (fd_out == -1)\n\t{\n\t\twrite(2, \"Erreur outfile\\n\", 15);\n\t\tclose(fd_in);\n\t\treturn (1);\n\t}\n\t// ... utiliser fd_in et fd_out ...\n\tclose(fd_in);\n\tclose(fd_out);\n\treturn (0);\n}",
          "language": "c",
          "tryItYourself": {
            "instruction": "Quels flags d'open utilise-t-on pour le fichier de sortie et pourquoi ?",
            "starterCode": "// O_WRONLY : ???\n// O_CREAT : ???\n// O_TRUNC : ???\n// Permissions 0644 : ???",
            "solution": "// O_WRONLY : ouvrir en ecriture seule\n// O_CREAT : creer le fichier s'il n'existe pas\n// O_TRUNC : vider le fichier s'il existe deja\n// 0644 : rw-r--r-- (lecture/ecriture owner, lecture groupe/autres)"
          }
        },
        {
          "id": 3,
          "title": "Le fils 1 : infile -> cmd1 -> pipe",
          "content": "Le premier fils doit :\n1. Rediriger stdin depuis le fichier d'entree : `dup2(fd_in, 0)`\n2. Rediriger stdout vers le pipe : `dup2(fd[1], 1)`\n3. Fermer tous les descripteurs inutiles\n4. Executer la commande avec execve\n\nAinsi, cmd1 lira depuis infile et ecrira dans le pipe.",
          "codeExample": "// Fils 1 : execute cmd1\nif (fork() == 0)\n{\n\t// Rediriger stdin <- infile\n\tdup2(fd_in, STDIN_FILENO);\n\t// Rediriger stdout -> pipe\n\tdup2(fd[1], STDOUT_FILENO);\n\t// Fermer tout ce qu'on n'utilise plus\n\tclose(fd_in);\n\tclose(fd_out); // Le fils 1 n'a pas besoin du outfile\n\tclose(fd[0]);\n\tclose(fd[1]);\n\t// Executer la commande\n\tchar *args[] = {cmd1, NULL};\n\texecve(cmd1_path, args, envp);\n\texit(1);\n}",
          "language": "c",
          "tryItYourself": {
            "instruction": "Pourquoi le fils 1 doit-il fermer fd_out en plus des descripteurs du pipe ?",
            "starterCode": "// Le fils 1 n'utilise pas fd_out car ???\n// S'il ne le ferme pas : ???",
            "solution": "// Le fils 1 n'utilise pas fd_out car c'est le fils 2 qui ecrit dedans\n// S'il ne le ferme pas : fuite de descripteur, et le fichier\n// pourrait ne pas etre correctement ferme a la fin"
          }
        },
        {
          "id": 4,
          "title": "Le fils 2 : pipe -> cmd2 -> outfile",
          "content": "Le second fils doit :\n1. Rediriger stdin depuis le pipe : `dup2(fd[0], 0)`\n2. Rediriger stdout vers le fichier de sortie : `dup2(fd_out, 1)`\n3. Fermer tous les descripteurs inutiles\n4. Executer la commande avec execve\n\nAinsi, cmd2 lira depuis le pipe (sortie de cmd1) et ecrira dans outfile.\n\n**Le programme complet combine tout :** open + pipe + fork x2 + dup2 + execve + close + wait.",
          "codeExample": "// Fils 2 : execute cmd2\nif (fork() == 0)\n{\n\t// Rediriger stdin <- pipe\n\tdup2(fd[0], STDIN_FILENO);\n\t// Rediriger stdout -> outfile\n\tdup2(fd_out, STDOUT_FILENO);\n\t// Fermer tout\n\tclose(fd_in);\n\tclose(fd_out);\n\tclose(fd[0]);\n\tclose(fd[1]);\n\t// Executer\n\tchar *args[] = {cmd2, NULL};\n\texecve(cmd2_path, args, envp);\n\texit(1);\n}\n// Parent : fermer tout et attendre\nclose(fd_in);\nclose(fd_out);\nclose(fd[0]);\nclose(fd[1]);\nwait(NULL);\nwait(NULL);",
          "language": "c"
        }
      ]
    },
    "theory": [
      {
        "title": "L'architecture de pipex",
        "content": "pipex est un programme qui reproduit le comportement de la commande shell '< infile cmd1 | cmd2 > outfile'. Il combine toutes les primitives de programmation systeme Unix.",
        "codeExamples": [
          {
            "title": "Schema complet de pipex",
            "code": "// ./pipex infile \"cat\" \"wc\" outfile\n// Equivalent a : < infile cat | wc > outfile\n//\n// Architecture :\n//\n// infile -(open/dup2)-> [Fils 1: cat] -(pipe)-> [Fils 2: wc] -(dup2/open)-> outfile\n//\n// Fils 1 :\n//   stdin  = infile  (dup2(fd_in, 0))\n//   stdout = pipe    (dup2(pfd[1], 1))\n//\n// Fils 2 :\n//   stdin  = pipe    (dup2(pfd[0], 0))\n//   stdout = outfile (dup2(fd_out, 1))\n//\n// Parent :\n//   Ferme tout, wait x2",
            "explanation": "L'architecture de pipex avec les redirections de chaque processus"
          }
        ],
        "keyPoints": [
          "Deux processus fils connectes par un pipe",
          "Le fils 1 lit depuis infile et ecrit dans le pipe",
          "Le fils 2 lit depuis le pipe et ecrit dans outfile",
          "Le parent cree tout, ferme tout, et attend les deux fils"
        ],
        "commonMistakes": [
          "Ouvrir les fichiers apres le fork (ils doivent etre ouverts dans le bon fils)",
          "Oublier de fermer les descripteurs inutiles dans chaque processus",
          "Ne pas attendre les deux fils (zombies)"
        ]
      },
      {
        "title": "Ouverture de fichiers avec open()",
        "content": "open() est l'appel systeme pour ouvrir des fichiers. Il retourne un descripteur de fichier (fd) qu'on peut utiliser avec read, write et dup2.",
        "codeExamples": [
          {
            "title": "Flags d'open pour pipex",
            "code": "#include <fcntl.h>\n\n// Fichier d'entree : lecture seule\nint fd_in = open(\"infile\", O_RDONLY);\n// Retourne -1 si le fichier n'existe pas\n\n// Fichier de sortie : ecriture, creation, troncature\nint fd_out = open(\"outfile\",\n\tO_WRONLY | O_CREAT | O_TRUNC, 0644);\n// O_WRONLY : ecriture seule\n// O_CREAT  : cree si inexistant\n// O_TRUNC  : vide si existant\n// 0644     : permissions rw-r--r--\n\n// Mode append (pour bonus here_doc) :\nint fd_append = open(\"outfile\",\n\tO_WRONLY | O_CREAT | O_APPEND, 0644);\n// O_APPEND : ecrit a la fin du fichier",
            "explanation": "Les differents modes d'ouverture pour les fichiers d'entree et de sortie"
          }
        ],
        "keyPoints": [
          "O_RDONLY pour lire, O_WRONLY pour ecrire",
          "O_CREAT cree le fichier, O_TRUNC le vide, O_APPEND ecrit a la fin",
          "Le troisieme argument (permissions) n'est necessaire qu'avec O_CREAT",
          "open retourne -1 en cas d'erreur (verifier avec errno)"
        ],
        "commonMistakes": [
          "Oublier O_CREAT pour le fichier de sortie (erreur si le fichier n'existe pas)",
          "Oublier les permissions (0644) avec O_CREAT",
          "Ne pas gerer le cas ou open retourne -1"
        ]
      },
      {
        "title": "Recherche de commande dans PATH",
        "content": "Dans le vrai pipex, il faut trouver le chemin absolu de la commande en cherchant dans les repertoires de la variable PATH. Pour notre mini-pipex simplifie, on peut utiliser des chemins absolus.",
        "codeExamples": [
          {
            "title": "Trouver une commande dans PATH",
            "code": "#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nchar\t*find_cmd(char *cmd, char **envp)\n{\n\tchar\t*path;\n\tchar\t**dirs;\n\tchar\ttry[1024];\n\tint\t\ti;\n\n\t// Trouver PATH dans envp\n\ti = 0;\n\twhile (envp[i] && strncmp(envp[i], \"PATH=\", 5))\n\t\ti++;\n\tif (!envp[i])\n\t\treturn (NULL);\n\tpath = envp[i] + 5; // Sauter \"PATH=\"\n\t// Tester chaque repertoire\n\t// \"/usr/bin\" + \"/\" + \"ls\" = \"/usr/bin/ls\"\n\t// Si access(try, X_OK) == 0 -> trouve !\n\treturn (NULL); // Pas trouve\n}",
            "explanation": "Le vrai pipex doit chercher la commande dans PATH (simplifie ici)"
          }
        ],
        "keyPoints": [
          "PATH contient les repertoires ou chercher les executables",
          "On teste chaque repertoire avec access(path, X_OK)",
          "Si la commande contient un '/', c'est deja un chemin (pas besoin de PATH)",
          "execve a besoin du chemin ABSOLU (contrairement a execvp)"
        ],
        "commonMistakes": [
          "Oublier de chercher dans PATH (utiliser directement le nom de la commande)",
          "Ne pas tester si le fichier est executable avec access()",
          "Oublier d'ajouter '/' entre le repertoire et le nom de la commande"
        ]
      },
      {
        "title": "Gestion d'erreurs dans pipex",
        "content": "Un pipex robuste doit gerer toutes les erreurs possibles : fichier introuvable, commande introuvable, erreur de pipe ou de fork. Chaque erreur doit produire un message sur stderr.",
        "codeExamples": [
          {
            "title": "Gestion d'erreurs complete",
            "code": "void\terror_exit(char *msg)\n{\n\tperror(msg);\n\texit(1);\n}\n\nint\tmain(int argc, char **argv)\n{\n\tif (argc != 5)\n\t{\n\t\twrite(2, \"Usage: ./pipex infile cmd1 cmd2 outfile\\n\", 39);\n\t\treturn (1);\n\t}\n\tint fd_in = open(argv[1], O_RDONLY);\n\tif (fd_in == -1)\n\t\terror_exit(argv[1]);\n\tint fd_out = open(argv[4], O_WRONLY | O_CREAT | O_TRUNC, 0644);\n\tif (fd_out == -1)\n\t\terror_exit(argv[4]);\n\tint fd[2];\n\tif (pipe(fd) == -1)\n\t\terror_exit(\"pipe\");\n\t// ... fork et exec ...\n}",
            "explanation": "Chaque appel systeme est verifie et les erreurs sont affichees avec perror"
          }
        ],
        "keyPoints": [
          "Verifier argc en premier (doit etre 5 pour pipex basique)",
          "Tester le retour de open, pipe, fork, dup2 et execve",
          "Utiliser perror() pour les messages d'erreur sur stderr",
          "Codes de sortie : 127 = commande introuvable, 126 = pas executable"
        ],
        "commonMistakes": [
          "Ignorer les erreurs de open (continuer avec fd = -1)",
          "Ne pas afficher de message d'erreur (l'utilisateur ne sait pas ce qui a echoue)",
          "Oublier de fermer les fd deja ouverts avant de quitter en cas d'erreur"
        ]
      }
    ],
    "prepExercises": [
      {
        "id": 1,
        "title": "Ouvrir et lire un fichier",
        "instruction": "Ouvre un fichier en lecture et affiche son contenu sur stdout.",
        "starterCode": "#include <unistd.h>\n#include <fcntl.h>\n\nint\tmain(void)\n{\n\tint fd;\n\tchar buf[1024];\n\t// Ouvre \"test.txt\" et affiche son contenu\n\t// TON CODE ICI\n\treturn (0);\n}",
        "solution": "#include <unistd.h>\n#include <fcntl.h>\n\nint\tmain(void)\n{\n\tint fd;\n\tchar buf[1024];\n\tint n;\n\n\tfd = open(\"test.txt\", O_RDONLY);\n\tif (fd == -1)\n\t\treturn (1);\n\twhile ((n = read(fd, buf, 1024)) > 0)\n\t\twrite(1, buf, n);\n\tclose(fd);\n\treturn (0);\n}",
        "hint": "open(\"test.txt\", O_RDONLY) puis boucle read/write jusqu'a ce que read retourne 0.",
        "difficulty": 1
      },
      {
        "id": 2,
        "title": "Rediriger stdin depuis un fichier",
        "instruction": "Ouvre un fichier et redirige stdin depuis ce fichier avec dup2.",
        "starterCode": "#include <unistd.h>\n#include <fcntl.h>\n\nint\tmain(void)\n{\n\tint fd;\n\tchar buf[100];\n\t// Redirige stdin depuis \"test.txt\" et lis avec read(0, ...)\n\t// TON CODE ICI\n\treturn (0);\n}",
        "solution": "#include <unistd.h>\n#include <fcntl.h>\n\nint\tmain(void)\n{\n\tint fd;\n\tchar buf[100];\n\tint n;\n\n\tfd = open(\"test.txt\", O_RDONLY);\n\tif (fd == -1)\n\t\treturn (1);\n\tdup2(fd, 0);\n\tclose(fd);\n\tn = read(0, buf, 99);\n\twrite(1, buf, n);\n\treturn (0);\n}",
        "hint": "dup2(fd, 0) redirige stdin. Ensuite read(0, ...) lit depuis le fichier.",
        "difficulty": 2
      },
      {
        "id": 3,
        "title": "Rediriger stdout vers un fichier",
        "instruction": "Redirige stdout vers un fichier et ecris dedans avec write(1, ...).",
        "starterCode": "#include <unistd.h>\n#include <fcntl.h>\n\nint\tmain(void)\n{\n\tint fd;\n\t// Redirige stdout vers \"output.txt\" et ecris \"Hello\"\n\t// TON CODE ICI\n\treturn (0);\n}",
        "solution": "#include <unistd.h>\n#include <fcntl.h>\n\nint\tmain(void)\n{\n\tint fd;\n\n\tfd = open(\"output.txt\", O_WRONLY | O_CREAT | O_TRUNC, 0644);\n\tif (fd == -1)\n\t\treturn (1);\n\tdup2(fd, 1);\n\tclose(fd);\n\twrite(1, \"Hello\\n\", 6);\n\treturn (0);\n}",
        "hint": "open avec O_WRONLY | O_CREAT | O_TRUNC, puis dup2(fd, 1).",
        "difficulty": 2
      },
      {
        "id": 4,
        "title": "Cmd simple avec redirection d'entree",
        "instruction": "Fork un fils qui redirige stdin depuis un fichier et execute /bin/cat.",
        "starterCode": "#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint\tmain(void)\n{\n\t// Fork, fils redirige stdin et execve cat\n\t// TON CODE ICI\n\treturn (0);\n}",
        "solution": "#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint\tmain(void)\n{\n\tif (fork() == 0)\n\t{\n\t\tint fd = open(\"test.txt\", O_RDONLY);\n\t\tif (fd == -1)\n\t\t\texit(1);\n\t\tdup2(fd, 0);\n\t\tclose(fd);\n\t\tchar *args[] = {\"cat\", NULL};\n\t\tchar *envp[] = {NULL};\n\t\texecve(\"/bin/cat\", args, envp);\n\t\texit(1);\n\t}\n\twait(NULL);\n\treturn (0);\n}",
        "hint": "Dans le fils : open le fichier, dup2 vers stdin, execve cat.",
        "difficulty": 3
      },
      {
        "id": 5,
        "title": "Mini pipex simplifie",
        "instruction": "Combine tout : infile -> cat -> wc -> outfile (avec chemins absolus).",
        "starterCode": "#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint\tmain(void)\n{\n\t// Reproduis : < infile cat | wc -l > outfile\n\t// TON CODE ICI\n\treturn (0);\n}",
        "solution": "#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint\tmain(void)\n{\n\tint fd[2];\n\tint fd_in = open(\"infile\", O_RDONLY);\n\tint fd_out = open(\"outfile\", O_WRONLY | O_CREAT | O_TRUNC, 0644);\n\tchar *envp[] = {NULL};\n\n\tpipe(fd);\n\tif (fork() == 0)\n\t{\n\t\tdup2(fd_in, 0);\n\t\tdup2(fd[1], 1);\n\t\tclose(fd_in);\n\t\tclose(fd_out);\n\t\tclose(fd[0]);\n\t\tclose(fd[1]);\n\t\tchar *a[] = {\"cat\", NULL};\n\t\texecve(\"/bin/cat\", a, envp);\n\t\texit(1);\n\t}\n\tif (fork() == 0)\n\t{\n\t\tdup2(fd[0], 0);\n\t\tdup2(fd_out, 1);\n\t\tclose(fd_in);\n\t\tclose(fd_out);\n\t\tclose(fd[0]);\n\t\tclose(fd[1]);\n\t\tchar *a[] = {\"wc\", \"-l\", NULL};\n\t\texecve(\"/usr/bin/wc\", a, envp);\n\t\texit(1);\n\t}\n\tclose(fd_in);\n\tclose(fd_out);\n\tclose(fd[0]);\n\tclose(fd[1]);\n\twait(NULL);\n\twait(NULL);\n\treturn (0);\n}",
        "hint": "Fils 1 : stdin=infile, stdout=pipe. Fils 2 : stdin=pipe, stdout=outfile. Fermer tout dans chaque processus.",
        "difficulty": 4
      }
    ]
  },
  "starterCode": "#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint\tmain(int argc, char **argv)\n{\n\tint\t\tfd[2];\n\tint\t\tfd_in;\n\tint\t\tfd_out;\n\tchar\t*envp[] = {NULL};\n\n\t// Usage: ./pipex infile cmd1 cmd2 outfile\n\t// 1. Verifier argc == 5\n\t// 2. Ouvrir infile en lecture et outfile en ecriture\n\t// 3. Creer le pipe\n\t// 4. Fils 1 : stdin=infile, stdout=pipe, execve cmd1\n\t// 5. Fils 2 : stdin=pipe, stdout=outfile, execve cmd2\n\t// 6. Parent : fermer tout, wait x2\n\t(void)argc;\n\t(void)argv;\n\treturn (0);\n}",
  "solution": "#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nvoid\tft_putstr_fd(char *s, int fd)\n{\n\twhile (*s)\n\t\twrite(fd, s++, 1);\n}\n\nvoid\tchild1(int fd_in, int *fd, char *cmd, char **envp)\n{\n\tdup2(fd_in, STDIN_FILENO);\n\tdup2(fd[1], STDOUT_FILENO);\n\tclose(fd_in);\n\tclose(fd[0]);\n\tclose(fd[1]);\n\tchar *args[2];\n\targs[0] = cmd;\n\targs[1] = NULL;\n\texecve(cmd, args, envp);\n\tft_putstr_fd(\"Erreur: commande introuvable\\n\", 2);\n\texit(127);\n}\n\nvoid\tchild2(int fd_out, int *fd, char *cmd, char **envp)\n{\n\tdup2(fd[0], STDIN_FILENO);\n\tdup2(fd_out, STDOUT_FILENO);\n\tclose(fd_out);\n\tclose(fd[0]);\n\tclose(fd[1]);\n\tchar *args[2];\n\targs[0] = cmd;\n\targs[1] = NULL;\n\texecve(cmd, args, envp);\n\tft_putstr_fd(\"Erreur: commande introuvable\\n\", 2);\n\texit(127);\n}\n\nint\tmain(int argc, char **argv)\n{\n\tint\t\tfd[2];\n\tint\t\tfd_in;\n\tint\t\tfd_out;\n\tchar\t*envp[] = {NULL};\n\n\tif (argc != 5)\n\t{\n\t\tft_putstr_fd(\"Usage: ./pipex infile cmd1 cmd2 outfile\\n\", 2);\n\t\treturn (1);\n\t}\n\tfd_in = open(argv[1], O_RDONLY);\n\tif (fd_in == -1)\n\t{\n\t\tft_putstr_fd(\"Erreur: fichier d'entree\\n\", 2);\n\t\treturn (1);\n\t}\n\tfd_out = open(argv[4], O_WRONLY | O_CREAT | O_TRUNC, 0644);\n\tif (fd_out == -1)\n\t{\n\t\tclose(fd_in);\n\t\tft_putstr_fd(\"Erreur: fichier de sortie\\n\", 2);\n\t\treturn (1);\n\t}\n\tif (pipe(fd) == -1)\n\t\treturn (1);\n\tif (fork() == 0)\n\t\tchild1(fd_in, fd, argv[2], envp);\n\tif (fork() == 0)\n\t\tchild2(fd_out, fd, argv[3], envp);\n\tclose(fd_in);\n\tclose(fd_out);\n\tclose(fd[0]);\n\tclose(fd[1]);\n\twait(NULL);\n\twait(NULL);\n\treturn (0);\n}",
  "hints": [
    "Ouvre infile avec open(argv[1], O_RDONLY) et outfile avec open(argv[4], O_WRONLY | O_CREAT | O_TRUNC, 0644).",
    "Fils 1 : dup2(fd_in, 0) et dup2(fd[1], 1), ferme tout, execve. Fils 2 : dup2(fd[0], 0) et dup2(fd_out, 1), ferme tout, execve.",
    "Le parent ferme fd_in, fd_out, fd[0] et fd[1], puis fait wait(NULL) deux fois."
  ],
  "testCases": [
    {
      "id": 1,
      "description": "Pipe basique avec cat et wc",
      "stdin": "",
      "expectedStdout": "outfile contient le resultat de cmd1 | cmd2",
      "expectedExitCode": 0,
      "visible": true
    },
    {
      "id": 2,
      "description": "Fichier d'entree inexistant",
      "stdin": "",
      "expectedStdout": "message d'erreur sur stderr",
      "expectedExitCode": 1,
      "visible": false
    },
    {
      "id": 3,
      "description": "Commande inexistante",
      "stdin": "",
      "expectedStdout": "message d'erreur sur stderr",
      "expectedExitCode": 127,
      "visible": false
    }
  ],
  "constraints": {
    "allowedFunctions": ["write", "read", "open", "close", "pipe", "fork", "dup2", "execve", "wait", "waitpid", "exit", "access"],
    "forbiddenFunctions": ["printf", "system", "popen"],
    "maxExecutionTime": 5000,
    "maxMemory": 128
  },
  "relatedExercises": ["c-day57-ex00-ft-pipe-basic", "c-day57-ex01-ft-pipe-cmd"],
  "resources": [
    {
      "title": "Man open(2) - Linux manual page",
      "url": "https://man7.org/linux/man-pages/man2/open.2.html",
      "type": "documentation"
    },
    {
      "title": "Guide complet pipex - 42",
      "url": "https://csnotes.medium.com/pipex-tutorial-42-project-4469f5dd5901",
      "type": "article"
    }
  ]
}